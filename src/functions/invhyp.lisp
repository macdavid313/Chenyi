;;;; invhype.lisp
(in-package #:chenyi.sys)

(declaim (inline %acosh/f64 %asinh/f64 %atanh/f64))

(template (<t>)
  (defun %acosh/float (x)
    (declare (type <t> x)
             (optimize speed (space 0) (safety 0)))
    (let ((one (float 1 x))
          (two (float 2 x)))
      (declare (dynamic-extent one two))
      (cond ((> x (/ one (eps x))) ;;+GSL-SQRT-DBL-EPSILON+))
             (+ (log x) (log two)))
            ((> x two)
             (log (- (* two x)
                     (/ one (+ (sqrt (- (* x x) one)) x)))))
            ((> x one)
             (let ((tmp (float 0 x)))
               (declare (type <t> tmp)
                        (dynamic-extent tmp))
               (setq tmp (- x one))
               (log1p (+ tmp (sqrt (+ (* two tmp) (* tmp tmp)))))))
            ((= x one) (float 0 x))
            (t (nan x))))))

(template (<t>)
  (defun %acosh (x)
    (declare (type <t> x)
             (optimize speed (safety 0) (space 0)))
    (cl:acosh x)))

(defun acosh (x)
  "This function computes the hyperbolic arc cosine of x. It provides an alternative to the standard math function cl:acosh when x is not a Complex number."
  (typecase x
    (float32 (cond ((or (nan-p x) (infinity-p x)) x)
                   (t (%acosh/float (float32) x))))
    (float64 (cond ((or (nan-p x) (infinity-p x)) x)
                   (t (%acosh/float (float64) x))))
    (real (%acosh/float (float64) (float x 0d0)))
    (complex/f32 (%acosh (complex/f32) x))
    (complex/f64 (%acosh (complex/f64) x))
    (number (%acosh (number) x))
    (t (error 'domain-error :operation "acosh" :expect "Number"))))

(define-compiler-macro acosh (&whole form &environment env x)
  (cond ((and (constantp x env) (numberp x))
         (acosh x))
        (t form)))

(defun %asinh/f64 (x)
  (declare (type double-float x)
           (optimize speed (space 0) (safety 0)))
  (let ((a 0d0) (s -1))
    (declare (type double-float a)
             (type fixnum s)
             (dynamic-extent a s))
    (setq a (abs x)
          s (if (minusp x) -1 1))
    (cond ((> a (/ 1d0 +GSL-SQRT-DBL-EPSILON+))
           (* s (+ (log a) +ln2+)))
          ((> a 2d0)
           (* s (log (+ (* 2d0 a)
                        (/ 1d0 (+ a (sqrt (+ (* a a) 1))))))))
          ((> a +GSL-SQRT-DBL-EPSILON+)
           (let ((a2 0d0))
             (declare (type double-float a2)
                      (dynamic-extent a2))
             (setq a2 (* a a))
             (* s (log1p (+ a (/ a2 (+ 1 (sqrt (+ a2 1)))))))))
          (t x))))

(defun asinh (x)
  "This function computes the hyperbolic arc sine of x. It provides an alternative to the standard math function cl:asinh when x is not a Complex number."
  (unless (numberp x)
    (error 'domain-error :operation "asinh" :expect "Number"))
  (typecase x
    (double-float (%asinh/f64 x))
    (real (%asinh/f64 (float x 0d0)))
    (t (let ((r (realpart x))
             (i (imagpart x)))
         (ensure-double-float (r i)
           (cl:asinh (complex r i)))))))

(define-compiler-macro asinh (&whole form &environment env x)
  (cond ((and (constantp x env) (numberp x))
         (asinh x))
        (t form)))

(defun %atanh/f64 (x)
  (declare (type double-float x)
           (optimize speed (space 0) (safety 0)))
  (let ((a 0d0) (s -1))
    (declare (type double-float a)
             (type fixnum s)
             (dynamic-extent a s))
    (setq a (abs x)
          s (if (minusp x) -1 1))
    (cond ((> a 1d0) nan)
          ((= a 1d0)
           (if (minusp x) -inf inf))
          ((>= a 0.5d0)
           (* s 0.5d0 (log1p (/ (* 2d0 a)
                                (- 1d0 a)))))
          ((> a +GSL-DBL-EPSILON+)
           (* s 0.5d0 (log1p (+ (* 2d0 a)
                                (/ (* 2d0 a a)
                                   (- 1d0 a))))))
          (t x))))

(defun atanh (x)
  "This function computes the hyperbolic arc tangent of x. It provides an alternative to the standard math function cl:atanh when x is not a Complex number."
  (unless (numberp x)
    (error 'domain-error :operation "atanh" :expect "Number"))
  (typecase x
    (double-float (%atanh/f64 x))
    (real (%atanh/f64 (float x 0d0)))
    (t (let ((r (realpart x))
             (i (imagpart x)))
         (ensure-double-float (r i)
           (cl:atanh (complex r i)))))))

(define-compiler-macro atanh (&whole form &environment env x)
  (cond ((and (constantp x env) (numberp x))
         (atanh x))
        (t form)))
