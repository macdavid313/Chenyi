;;;; log1p.lisp
(in-package #:chenyi.sys)

(template (<t>)
  (defun %log1p/float (x)
    (declare (type <t> x)
             (optimize speed (safety 0) (space 0)))
    (let ((one (float 1 x)))
      (declare (type <t> one)
               (dynamic-extent one))
      (cond ((= x (the <t> (- one))) (inf x))
            ((< x (float -1 x))
             (the (complex <t>) (log (+ x one))))
            (t (let ((y (float 0 x))
                     (z (float 0 x)))
                 (declare (type <t> y z)
                          (dynamic-extent y z))
                 (setq y (+ x one))
                 (setq z (- y one))
                 ;; cancels errors with IEEE arithmetic
                 (- (the <t> (log y)) (/ (- z x) y))))))))
  
(template (<t>)
  (defun %log1p/complex (x)
    (declare (type <t> x)
             (optimize speed (safety 0) (space 0)))
    (log (+ (the <t> x) (float 1 (realpart x))))))

(defun log1p (x)
  "This function computes the value of log(1+x) in a way that is accurate for small x."
  (typecase x
    (float32 (%log1p/float (float32) x))
    (float64 (%log1p/float (float64) x))
    (real (%log1p/float (float64) (float x 0d0)))
    (complex/f32 (%log1p/complex (complex/f32) x))
    (complex/f64 (%log1p/complex (complex/f64) x))
    (complex (let ((r (realpart x))
                   (i (imagpart x)))
               (%log1p/complex (complex/f64)
                               (complex (float r 0d0) (float i 0d0)))))
    (t (error 'domain-error :operation "log1p" :expect "Number"))))

(define-compiler-macro log1p (&whole form &environment env x)
  (cond ((constantp x env)
         (log1p (constant-form-value x env)))
        (t form)))
