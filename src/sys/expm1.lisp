;;;; expm1.lisp
(in-package #:chenyi.sys)

(template (<t>)
  (defun %expm1/float (x)
    (declare (type <t> x)
             (optimize speed (safety 0) (space 0)))
    (let ((one (float 1 x)))
      (declare (type <t> one)
               (dynamic-extent one))
      (cond ((< (abs x) (float #.(log 2) x))
             (let ((i one)
                   (term (/ x one))
                   (sum x))
               (declare (type <t> i term sum))
               (do ()
                   ((<= (abs term) (* (abs sum) (eps x)))
                    sum)
                 (incf i one)
                 (setq term (* term (/ x i)))
                 (setq sum (+ sum term)))))
            (t (- (exp x) one))))))

(template (<t>)
  (defun %expm1/complex (x)
    (declare (type <t> x)
             (optimize speed (safety 0) (space 0)))
    (- (exp x) (float 1 (realpart x)))))

(defun expm1 (x)
  "Accurately compute e^x - 1"
  (handler-case
      (typecase x
        (float32 (%expm1/float (float32) x))
        (float64 (%expm1/float (float64) x))
        (real (%expm1/float (float64) (float x 0d0)))
        (complex/f32 (%expm1/complex (complex/f32) x))
        (complex/f64 (%expm1/complex (complex/f64) x))
        (complex (let ((r (realpart x))
                       (i (imagpart x)))
                   (%expm1/complex (complex/f64)
                                   (complex (float r 0d0) (float i 0d0)))))
        (t (error 'domain-error :operation "expm1" :expect "Number")))
    (floating-point-overflow (c)
      (declare (ignore c))
      (typecase x
        (real (inf x))
        (complex (inf (complex -inf (imagpart x))))))))
                             
(define-compiler-macro expm1 (&whole form &environment env x)
  (cond ((constantp x env)
         (expm1 (constant-form-value x env)))
        (t form)))
